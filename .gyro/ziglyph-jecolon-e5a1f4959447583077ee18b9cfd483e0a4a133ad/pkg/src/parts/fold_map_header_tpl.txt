// Autogenerated from http://www.unicode.org/Public/UCD/latest/ucd/UCD.zip by running ucd_gen.sh.
//! Unicode case folding map.

const std = @import("std");
const mem = std.mem;
const unicode = std.unicode;

const CaseFoldMap = @This();

/// caseFoldStr will caseFold the code points in str, producing a slice of u8 with the new bytes.
/// Caller must free returned bytes.
pub fn caseFoldStr(self: *CaseFoldMap, allocator: *mem.Allocator, str: []const u8) ![]u8 {
    var result = std.ArrayList(u8).init(allocator);
    defer result.deinit();
    var code_points = std.ArrayList(u21).init(allocator);
    defer code_points.deinit();

    // Gather decomposed code points.
    var iter = (try unicode.Utf8View.init(str)).iterator();
    while (iter.nextCodepoint()) |cp| {
        for (self.toCaseFold(cp)) |fcp| {
            if (fcp == 0) break;
            try code_points.append(fcp);
        }
    }

    // Encode as UTF-8 code units.
    var buf: [4]u8 = undefined;
    for (code_points.items) |dcp| {
        const len = try unicode.utf8Encode(dcp, &buf);
        try result.appendSlice(buf[0..len]);
    }

    return result.toOwnedSlice();
}

/// toCaseFold will convert a code point into its case folded equivalent. Note that this can result
/// in a mapping to more than one code point, known as the full case fold.
pub fn toCaseFold(self: CaseFoldMap, cp: u21) [3]u21 {
