
    return instance;
}}

const Self = @This();
pub fn deinit(self: *Self) void {{
    var iter = self.map.iterator();
    while (iter.next()) |entry| {{
        self.allocator.destroy(entry.value);
    }}
    self.map.deinit();
}}

/// SpecialCaseMap can be a simple, one code point value or a sequence of code points.
pub const SpecialCaseMap = union(enum) {{
    single: u21,
    seq: []const u21,
}};

pub const Kind = enum {{
    Lowercase,
    Titlecase,
    Uppercase,
}};

/// toLowerSpecial will convert a code point into its lowercase equivalent for special cases.
pub fn toLowerSpecial(self: Self, cp: u21, countries: ?[][]const u8, conditions: ?[][]const u8) SpecialCaseMap {{
    return self.toSpecialCase(cp, .Lowercase, countries, conditions);
}}

/// toTitleSpecial will convert a code point into its titlecase equivalent for special cases.
pub fn toTitleSpecial(self: Self, cp: u21, countries: ?[][]const u8, conditions: ?[][]const u8) SpecialCaseMap {{
    return self.toSpecialCase(cp, .Titlecase, countries, conditions);
}}

/// toUpperSpecial will convert a code point into its uppercase equivalent for special cases.
pub fn toUpperSpecial(self: Self, cp: u21, countries: ?[][]const u8, conditions: ?[][]const u8) SpecialCaseMap {{
    return self.toSpecialCase(cp, .Uppercase, countries, conditions);
}}

fn toSpecialCase(self: Self, kind: Kind, cp: u21, countries: ?[][]const u8, conditions: ?[][]const u8) SpecialCaseMap {{
    if (self.map.get(cp)) |sm| {{
        var countries_match = true;
        var conditions_match = true;
        if (countries) |cous| {{
            countries_match = matchAll(sm.countries, cous);
        }}
        if (conditions) |conds| {{
            conditions_match = matchAll(sm.conditions, conds);
        }}
        if (countries_match and conditions_match) {{
            const index = @enumToInt(kind);
            if (sm.mappings[index].len == 1) {{
                return .{{ .single = sm.mappings[index][0] }};
            }} else {{
                return .{{ .seq = sm.mappings[index] }};
            }}
        }} else {{
            return .{{ .single = cp }};
        }}
    }} else {{
        return .{{ .single = cp }};
    }}
}}

fn matchAll(comptime T: type, a: [][]const T, b: [][]const T) bool {{
    for (a) |ai| {{
        for (b) |bi| {{
            if (!mem.eql(T, ai, bi)) return false;
        }}
    }}
    return true;
}}
