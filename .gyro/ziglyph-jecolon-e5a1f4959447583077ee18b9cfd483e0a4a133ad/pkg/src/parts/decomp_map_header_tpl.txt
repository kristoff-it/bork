// Autogenerated from http://www.unicode.org/Public/UCD/latest/ucd/UCD.zip by running ucd_gen.sh.
//! Unicode decomposition map.

const std = @import("std");
const mem = std.mem;
const sort = std.sort.sort;
const unicode = std.unicode;

const CccMap = @import("../DerivedCombiningClass/CccMap.zig");
const HangulMap = @import("../HangulSyllableType/HangulMap.zig");
const NFDCheck = @import("../DerivedNormalizationProps/NFDCheck.zig");

/// Decomposed is the result of a code point full decomposition. It can be one of:
/// * .src: Sorce code point.
/// * .same : Default canonical decomposition to the code point itself.
/// * .single : Singleton canonical decomposition to a different single code point.
/// * .canon : Canonical decomposition, which always results in two code points.
/// * .compat : Compatibility decomposition, which can results in at most 18 code points.
pub const Decomposed = union(enum) {
    src: u21,
    same: u21,
    single: u21,
    canon: [2]u21,
    compat: []const u21,
};

ccc_map: CccMap,
hangul_map: HangulMap,
nfd_check: NFDCheck,

const Self = @This();

pub fn new() Self {
    return Self{
        .ccc_map = CccMap{},
        .hangul_map = HangulMap{},
        .nfd_check = NFDCheck{},
    };
}

/// mapping retrieves the decomposition mapping for a code point as per the UCD.
pub fn mapping(self: Self, cp: u21) Decomposed {
